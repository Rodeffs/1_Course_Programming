// Указатели и оперативная память

#include <iostream>
#include <chrono>
#include <thread>

using std::cout;
using std::cin;
using std::endl;

void swap(int* a, int* b) { // swap с применением указателей

    int tmp = *a;
    *a = *b;
    *b = tmp;
}

/* 
    float p = (float)1/2; преобразование c - style
    float p = static_cast<float>(1)/2; преобразование c++ (в <> пишем во что преобразуем, в () пишем что преобразуем)
*/


int main()
{
    char c = 97; // то же, что и char c = 'a'

    char* p = &c; // значение p - это адрес переменной c

    char c1 = *p; // *p - разыменование переменной p, значение c1 - это значение переменной c (97)

    &p; // это адрес указателя p, & возвращает адрес

    char** p1 = &p; // p1 хранит адрес указателя p

    char c2 = *(*p1); // c2 хранит значение p


    // nullptr - нулевое значение для указателя


    // Есть два типа памяти:
    
    // stack (стэк) - фиксированная память, место резервируется при запуске

    // Пример стэка:
    {
        int a = 5; // - оперативная память освобождается автоматически после исполнения
    }


    // heap (хип) - динамическая память

    // Пример хипа:
    {
        int n;
        cin >> n;
        int* m = new int[n]; // создать 10000 переменных типа int и сохранить их адрес первой из них в переменной int* m

    /* Проблемы хипа:
     1. Затрата по времени на выделение памяти
     2. Память нужно очищать вручную (сборщик мусора)
    */

        delete[] m; // помечает ячейки памяти как неиспользуемые

        // malloc = memory allocate
        // free - то же, что и delete
    }

    for (int i = 0; i < 1000; i++) {

        int* m = new int[100000000]; // Выделение 4 Мб, каждый раз будет выделятся свободные ячейки памяти, при этом старые очищаться не будут

        std::this_thread::sleep_for(std::chrono::microseconds(2000)); // Задержка на 2 секунды

        delete[] m; // Очистить значения m, чтобы не засорить оперативную память

        std::this_thread::sleep_for(std::chrono::microseconds(2000));
    }


    /* Это проверка на ошибку: try{} если ошибки нет, catch (название ошибки) {} в случае возникновения ошибки
    try {
        char b = static_cast<char>(a);
    }
    catch (...) {
        cout << "123" << endl;
    }
    */


    // Создание двумерного массива:
    int k = 3;
    int l = 5;
    int** mas = new int* [k];
    for (int i = 0; i < k; i++) 
        mas[i] = new int[l];
    
    mas[0][1]; 

    for (int i = 0; i < k; i++)
        delete[] mas[i];
    delete[] mas;
}


