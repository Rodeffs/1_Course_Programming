/* Лекция №1 (13). Постоянные переменные, указатели и прочее */
#include <iostream>
#include <cstring>

using std::cin;
using std::cout;
using std::string;
using std::endl;

struct A {
    int a = 1; // 4 байта
    char b = 2; // тоже будет 4 байта, а не 1 байт, из-за выравнивания (так проще для процессора, т.к. нужно чтобы размер каждого элемента был кратем машинному слову)
    int c = 3; // 4 байта
};

struct String {
private:
    unsigned int m_size;
    char* m_str; // этот массив может иметь миллионы строк
    mutable int m_counter = 0; // отмена const, стоит использовать КРАЙНЕ осторожно, используется для того например, чтобы узнать, сколько раз выполнилась программа
public:
    String(char* str) {
        m_size = strlen(str); // strlen идёт до терминирующего символа
        m_str = new char[m_size+1]; // выделение памяти
        std::copy(str, str + m_size + 1, m_str); // memcpy, т.е. копирование
    }

    String(char c, size_t size) { // неявное преобразование типа int в char
        m_size = size;
        m_str = new char[m_size];
        for (int i = 0; i < m_size; i++)
            m_str[i] = c;
    }

    size_t size() const { // size_t - это то же, что и unsigned long long, либо unsigned int, зависит от системы
        return m_size;
    }

    void print() const { // константный метод - он гарантирует, что поля не меняются
//        m_size++; - так не выйдет, т.к. константный метод не даёт изменить поле класса
        m_counter++; // это возможно благодаря mutable
        cout << m_str << endl;
    }
};

int numOfVoices(const std::string& s) { // то есть std::string& s = str. В данном случае const не очень нужен, однако он предотвращает изменение s, т.к. мы не хотим этого
//    s[2] = '2'; - const не дал изменить значение s
}

int main() {
    String s("Hello, world!");
    s.print();
    cout << s.size() << std::endl;

//    int n = 10;
//    n = 12;
//    int mas[n]; - не стоит так делать, т.к. фиксированный массив не может иметь переменную длину

    const int n = 10;
    int mas[n]; // теперь фиксированный массив определён правильно

    /* Указатели: */
//    int* p = &n; - так нельзя, т.к. типы не будут соответствовать

    const int* p = &n; // указатель на константу
//    *p = 10; - не можем изменить значение, т.к. *p (то есть n) это константа
    p += 1; // а вот p изменить можем, т.к. это указатель переменный

    int x = 10;
    int* const q = &x; // константный указатель
    *q = 12; // можем изменить значение, т.к. *q (то есть x) переменная
//    q += 1; - а вот q изменить не можем, т.к. это константа

    const int* const p2 = &n; // константный указатель на константу
    // в таком случае не можем изменить значения ни переменной, ни константы, т.к. они оба константы

    const int& y = n; // ссылка на константу
//    int& const u = n; - константная ссылка, так писать нельзя, сначала нужно инициализировать ссылку
    // данная запись неверна, т.к. ссылка присваивается конкретному значению и перебросить эту ссылку на другое значение нельзя

    int t = 10;
    int& link = x; // инициализация link, т.е. link и x - одно и то же
    link = t; // теперь x = t, таким образом ссылку нельзя поменять


    // Ссылки нужны, чтобы не пришлось копировать значения, т.к. тогда очень быстро расходуется память
    std::string str = "BIG STRING";
    numOfVoices(str);

    return 0;
}
