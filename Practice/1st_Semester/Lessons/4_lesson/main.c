#include <stdio.h>
#include <math.h> // Здесь находится pow()

int bitnumber (int a) {
    for (int i = 1; i < 32; i++) {
        if (a < (1 << i)) // Кол-во бит, занимаемой числом определяется наименьшей степени двойки, которой число меньше
            return i;
    }
    return 0;
}

int main(int argc, char *argv[])
{
                                                                      /*      Битовые сдвиги       */

    int numberForExample = 4;

    int left = numberForExample << 1; // Побитовый сдвиг влево, к двоичной записи справа добавляется 0 и все биты сдвигаются влево. То же, что и умножение на 2

    int right =  numberForExample >> 1;  // Побитовый сдвиг влево, самый правый бит удаляетя, остальные сдвигаются вправо. То же, что и деление на 2

    numberForExample >>= 2;


    /*

    && - логическое И
    & - побитовое УМНОЖЕНИЕ
    || - логическое ИЛИ
    | - побитовое СЛОЖЕНИЕ

    ^ - операция XOR (исключающее ИЛИ, 1 ^ 1 = 0, в остальном такое, как и ИЛИ)

    ~ - побитовая инверсия

    0x - префикс 16-чной системы
    0b - 2-чная система, в Си её нет

    */


    numberForExample & 0x80000000; // Значение самого левого бита

    numberForExample & 1; // Значение самого правого бита

    numberForExample & 0xF; // Значение в 16-чной системе


                                                                   /* Перевод в двоичную систему: */

    int a = 25; // Число, которое переводим

    for (int i = 1; i < 32; i++)
       printf("%d", (a & (1 << (31-i))) != 0 ? 1 : 0); // Проверяем значение самого левого бита, возводя 2 в степень i и делая побитовое умножение, затем выводим 1, если значение не равняется 0, или 0




    printf("\n\n");



                                                             /* Перевод в шестнадцатеричную систему: */

    int c = 30; // Число, которое переводим

    for (int i = 1; i < 9; i++) {
        int b = (c >> (32 - (i*4))); // Таким образом мы разбиваем число в 2-чной системе на 4 бита, но отнимаем от 32, дабы начинать с самой левой четвёрки
        int tmp = b & 0xF;
        if (tmp < 10)
            printf("%d", tmp);
        else {
            switch (tmp) { // Оператор switch()
            case 10:
                printf("A");
                break;
            case 11:
                printf("B");
                break;
            case 12:
                printf("C");
                break;
            case 13:
                printf("D");
                break;
            case 14:
                printf("E");
                break;
            case 15:
                printf("F");
                break;
            }
        }
    }





    printf("\n\n");



                                                          /* Последний бит переносим в начало, а остальное сдвигаем вправо */

    int d = 1; // Число, которое переставляем

    int n = bitnumber(d); // Определяем сколько бит занимает число

    for (int i = 1; i < n; i++) {
        int d1 = d & 1; // Запоминаем последний бит
        d >>= 1; // Сдвигаем вправо
        d += d1 * pow(2, n-1); // Прибваляем в начало этот бит, умножая его на степень двойки n - 1 (т.к. если мы возьмём просто n, то получившееся число превысит изначальное кол-во бит)
        printf("%d\n", d);
    }
    return 0;
}
