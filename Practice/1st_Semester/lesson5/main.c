// Лекция 5

#include <stdio.h>


void swap(int *c, int *d) { // swap() работает только для указателей, при этом значения переменных менеятся
    int t = *c;
    *c = *d;
    *d = t;
}


void myfunc(int *p, int n);
// void myfunc(int x[], int n); - то же, но лучше писать через указатель





// -----------------------------------------------------------------------------------------------------------------------------------------------------






int strLen(char *s) { // Вычисление длины строки (1 способ).

    int i; // Таким образом нам не нужно считать ничего лишнего

    for (i = 0; s[i] != 0; i++);  // s[i] != 0 - таким образом мы идём до конца строки. Можно также просто написать s[i]

    return i; // Нам вернётся число, сколько раз мы пробежали по циклу, что как раз и является длиной строки
}



int strLen2(char *s) { // Вычисление длины строки (2 способ).

    int n = 0;

//    while (*s) { // Читается так: если символ не 0, то счётчик увеличиваем на 1 и продвигаем указатель на 1
//        n++;
//        s++;
//    }

    while (*s++) // То же, что и выше, только более оптимизирован
        n++;

    return n;
}



int strLen3(char *s) { // Вычисление длины строки (3 способ).

    char *q = s;

    while (*s++); // Цикл идёт, пока он не уткнётся в символ с кодом 0 (не число 0, а именно с кодом 0, т.е. \0)

    return s-q-1; // Мы вычитаем разницу между начальным указателем и тем, до которого дошли. Мы вычитаем 1, т.к. нам не нужен терм. символ

}



void strCopy (char *s, char *p) { // Присваивание значений s = p

//    while (*p) {
//        *s = *p;
//        p++;
//        s++;
//    }
//    *s = '\0'; // Чтобы и терм. символ скопировался

    while (*s++=*p++); // То же, что и выше, только более оптимизирован
}



char *strChar (char *s, char c) { // Поиск элемента c в строке *s. Если не нашёл, то вернуть NULL

//    for (int i = 0; s[i]; i++) {
//        if (s[i] == c) {
//            return i+1;
//        }
//    }
//    return NULL;


//    while (*s) {
//        if (*s == c)
//            return s; // s в таком случае как раз и указывает на c
//        s++;
//    }
//    return NULL;

    while (*s++) { // В таком случае мы уже переходим на следующий символ
        if (s[-1] == c) // Поэтому и сравниваем с предыдущим
            return s-1;
    }
    return NULL;
}



int strComp (char *s, char *p) { // Сравнение строк (1 способ). Если s > p, то вернуть 1, если s < p, то вернуть -1, если s = p, то вернуть 0

    /*

     "abc" < "b"

     "abc" == "abc"

     "ab" < "abc"

    */

    while (*s && *p) { // Пока обе строки != 0

        if (*s < *p)
            return 0;
        else if (*s > *p)
            return 1;
        *s++;
        *p++;
    }

    if (*s == NULL && *p != NULL) // * здесь нужна, т.к. указатель может иметь значение NULL, а просто s или p - не могут
        return 0;
    else if (*s != NULL && *p == NULL)
        return 1;

    return 0;
}



int strComp2 (char *s, char *p) { //  Сравнение строк (2 способ).

    while (*s && *p && *s==*p) {
        s++;
        p++;
    }

    return *s - *p;
}



int pal (char *s) {

    int len = strLen3(s); // Длина строки, см. выше

    for (int i = 0; i < len/2; i++) {
        if (s[i] != s[len-1-i]) // Идём с двух концов до середины и проверяем
            return 0;
    }
    return 1;
}



int brackets (char *b) {
    int c1 = 0;
    int c2 = 0;

    if (*b == ')')
        return 0; // Этот костыль нужен, т.к. никакое математическое выражение не может начинаться с закрывающей скобки

    while (*b) {
        if (*b == '(')
            c1++;
        else if (*b == ')')
            c2++;
        b++;

    }

    return (c1 == c2); // Если равно, вернётся 1, если нет, то 0
}



int main(int argc, char *argv[])
{

                                                         /* Указатели */


    int *a, x = 2; // * означает, что а - указатель

    // a = 0; -  указателю нельзя присваивать числовые значения, кроме 0


    a = &x;
    *a = 5; // Значение x теперь 5

    int c = *a + 2;

    // char * - то же, что и %s (строка)



    int y[10] = {1, 2, 3};

    a = &y[2]; // Через знак & берём адрес любой переменной, включая массивы

    // Выражение a+1 (или a++) - это следующий элемент массива


    // !!! Складывать и вычитать указатели нельзя, только если они не указывают на один и тот же массив



    a[0]; // Тот же элемент, на который указывает а

    a[-1]; // Предыдущий элемент до а

    a[1]; // Следующий элемент после а

    // a[i] это то же самое, что и *(a+i)




    char *s = "abcd"; // Таким образом мы преобразуем строку в строчный массив

    /*

    *s == 'a';
    s[1] = 'b'; - также, как и в Питоне

    */


    char s2[] = {'a', 'b', 'c', 'd', '\0'}; // \0 - терминарный символ, то же, что и 0. Замечание: всё, что идёт после \ считается в 8-чной системе

    /*

    "a" - занимает 2 байта: а и 0 (терм. символ)
    'a' - занимает 1 байт - только а

    */


    /*

    Допустим, p указывает на элемент массива 5 {..., 5, 6, ....}

        *p++; - возьмёт 5, но указатель передвинется на 6

        (*p)++; - возьмёт 6, но указатель не изменится

        *++p; - забыл

        *(p++); - возьмёт 6 и указатель передвинется на 6


    */

// -----------------------------------------------------------------------------------------------------------------------------------------------------


                                                          /* Функции с указателями */

    // Длина строки:
    char *sample = "abcdefg";

    printf("The string '%s' has %d symbols\n", sample, strLen(sample));



    // Замена строки:
    char bb[10];

    strCopy(bb, "ThisStringHasBeenCopied");

    printf("%s\n", bb); // %s нужно, т.к. это строчное значение



    // Первое вхождение символа в строке:
    char *s1 = "Hello";

    char *q = strChar(s1, 'o');

    printf("%p   %p   %c\n", s, q, *q); // %c - символ, %p - код указателя в 16-чной системе




    // if (!q); - то же, что и if (q != 0)



    // Сравнение строк:
    char *a1 = "abcd";

    char *b1 = "abcd";

    printf("Is '%s' bigger than '%s' (in terms of ASCII encoding)? Answer: %s\n", a1, b1, strComp(a1, b1) ? "YES" : "NO"); // Я использовал тернарный алгоритм, дабы выглядело лучше (Является ли strComp() правдой? Если да, то выведется YES, если нет, то NO. %s указывает на то, что это строчные значения).



    // Строка-палиндром (слово одинаково с двух сторон):
    char *qa = "ahkkha";

    printf("Is the word '%s' a palindrome? Answer: %s\n", qa, pal(qa) ? "YES" : "NO");



    // Скобочки:
    char *m = "()()())";

    printf("Can '%s' be a math equation? Answer: %s\n", m, brackets(m) ? "YES" : "NO");

    return 0;
}
